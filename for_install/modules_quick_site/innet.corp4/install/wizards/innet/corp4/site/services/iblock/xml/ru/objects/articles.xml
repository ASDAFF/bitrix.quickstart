<?xml version="1.0" encoding="windows-1251"?>
<КоммерческаяИнформация ВерсияСхемы="2.021" ДатаФормирования="2017-04-18T14:06:05">
	<Классификатор>
		<Ид>10</Ид>
		<Наименование>Статьи</Наименование>
		<Свойства>
			<Свойство>
				<Ид>CML2_ACTIVE</Ид>
				<Наименование>БитриксАктивность</Наименование>
				<Множественное>false</Множественное>
			</Свойство>
			<Свойство>
				<Ид>CML2_CODE</Ид>
				<Наименование>Символьный код</Наименование>
				<Множественное>false</Множественное>
			</Свойство>
			<Свойство>
				<Ид>CML2_SORT</Ид>
				<Наименование>Сортировка</Наименование>
				<Множественное>false</Множественное>
			</Свойство>
			<Свойство>
				<Ид>CML2_ACTIVE_FROM</Ид>
				<Наименование>Начало активности</Наименование>
				<Множественное>false</Множественное>
			</Свойство>
			<Свойство>
				<Ид>CML2_ACTIVE_TO</Ид>
				<Наименование>Окончание активности</Наименование>
				<Множественное>false</Множественное>
			</Свойство>
			<Свойство>
				<Ид>CML2_PREVIEW_TEXT</Ид>
				<Наименование>Анонс</Наименование>
				<Множественное>false</Множественное>
			</Свойство>
			<Свойство>
				<Ид>CML2_DETAIL_TEXT</Ид>
				<Наименование>Описание</Наименование>
				<Множественное>false</Множественное>
			</Свойство>
			<Свойство>
				<Ид>CML2_PREVIEW_PICTURE</Ид>
				<Наименование>Картинка анонса</Наименование>
				<Множественное>false</Множественное>
			</Свойство>
		</Свойства>
		<Группы>
		</Группы>
	</Классификатор>
	<Каталог>
		<Ид>10</Ид>
		<ИдКлассификатора>10</ИдКлассификатора>
		<Наименование>Статьи</Наименование>
		<БитриксКод>articles</БитриксКод>
		<БитриксСортировка>40</БитриксСортировка>
		<БитриксURLСписок>#SITE_DIR#/articles/</БитриксURLСписок>
		<БитриксURLДеталь>#SITE_DIR#/articles/#ELEMENT_CODE#/</БитриксURLДеталь>
		<БитриксURLРаздел>#SITE_DIR#/articles/#SECTION_CODE#/</БитриксURLРаздел>
		<БитриксURLКанонический></БитриксURLКанонический>
		<БитриксКартинка></БитриксКартинка>
		<БитриксИндексироватьЭлементы>true</БитриксИндексироватьЭлементы>
		<БитриксИндексироватьРазделы>true</БитриксИндексироватьРазделы>
		<БитриксДокументооборот>false</БитриксДокументооборот>
		<БитриксПодписи>
			<БитриксПодпись>
				<Ид>ELEMENT_NAME</Ид>
				<Значение>Элемент</Значение>
			</БитриксПодпись>
			<БитриксПодпись>
				<Ид>ELEMENTS_NAME</Ид>
				<Значение>Элементы</Значение>
			</БитриксПодпись>
			<БитриксПодпись>
				<Ид>ELEMENT_ADD</Ид>
				<Значение>Добавить элемент</Значение>
			</БитриксПодпись>
			<БитриксПодпись>
				<Ид>ELEMENT_EDIT</Ид>
				<Значение>Изменить элемент</Значение>
			</БитриксПодпись>
			<БитриксПодпись>
				<Ид>ELEMENT_DELETE</Ид>
				<Значение>Удалить элемент</Значение>
			</БитриксПодпись>
			<БитриксПодпись>
				<Ид>SECTION_NAME</Ид>
				<Значение>Раздел</Значение>
			</БитриксПодпись>
			<БитриксПодпись>
				<Ид>SECTIONS_NAME</Ид>
				<Значение>Разделы</Значение>
			</БитриксПодпись>
			<БитриксПодпись>
				<Ид>SECTION_ADD</Ид>
				<Значение>Добавить раздел</Значение>
			</БитриксПодпись>
			<БитриксПодпись>
				<Ид>SECTION_EDIT</Ид>
				<Значение>Изменить раздел</Значение>
			</БитриксПодпись>
			<БитриксПодпись>
				<Ид>SECTION_DELETE</Ид>
				<Значение>Удалить раздел</Значение>
			</БитриксПодпись>
		</БитриксПодписи>
		<Товары>
			<Товар>
				<Ид>37</Ид>
				<Наименование>Определение и применение рефакторинга кода</Наименование>
				<БитриксТеги></БитриксТеги>
				<Группы>
				</Группы>
				<Картинка>articles_files/iblock/b29/b29ca257d05951283410290e057c05e9.jpg</Картинка>
				<ЗначенияСвойств>
					<ЗначенияСвойства>
						<Ид>CML2_ACTIVE</Ид>
						<Значение>true</Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_CODE</Ид>
						<Значение>opredelenie-i-primenenie-refaktoringa-koda</Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_SORT</Ид>
						<Значение>500</Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_ACTIVE_FROM</Ид>
						<Значение>2014-02-01 00:00:00</Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_ACTIVE_TO</Ид>
						<Значение></Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_PREVIEW_TEXT</Ид>
						<Значение>Что такое рефакторинг кода понять несложно – определений в сети достаточно много.</Значение>
						<Тип>text</Тип>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_DETAIL_TEXT</Ид>
						<Значение>Что такое рефакторинг кода понять несложно – определений в сети достаточно много. Наиболее удачное и полное, на мой взгляд, в википедии, и не только потому, что оно исчерпывающее, но и потому, что в нем рефакторинг противопоставляется таким этапам жизненного цикла программных продуктов, как оптимизация и реинжиниринг. Познакомиться с этим вариантом определения легко, набрав в строке интернет поиска слово &quot;Рефакторинг&quot; и открыв (скорее всего первую) ссылку на сайт свободной энциклопедии.

Итак, рефакторинг кода – это процесс внесения изменений в исходный код программы посредством небольших преобразований, смысл которых эквивалентен прежним фрагментам, но результат выглядит более стройным, органичным и логичным.
Когда уместно проводить рефакторинг кода?

В жизни каждой программы, по крайней мере, в жизни тех, что разрабатываются на заказ, наступает этап, когда основные функциональные требования заказчика, по мнению разработчика, выполнены, и программный продукт поступает на тестирование. А может быть даже в опытную эксплуатацию. В ходе тестирования, если у того, кто его проводит, руки растут из нужного места и мозги работают в правильном направлении, на разработчика начинает валиться большое число bug-ов, связанных с исключительными ситуациями, “защитой от дурака”, экстремальными объемами данных, неприемлемым быстродействием и так далее (идеально работающие программы сразу не пишутся). Разработчик старается быстро реагировать на вызовы судьбы и вносит большое количество локальных исправлений, а иногда и “заплат”, вследствие чего код теряет первоначальную стройность и сбалансированность. Вот в моменты между основными волнами наплывов претензий со стороны отдела технического контроля или просто ОТК и следует проводить рефакторинг кода: анализировать код и, используя ряд эффективных приемов, преобразовывать его к более согласованному и “прозрачному виду.” Естественно, что этап рефакторинга нельзя считать однократным.

Также, уместно проводить рефакторинг кода после добавления новой функциональности, поскольку такие действия легко могут привести к необходимости провести ряд преобразований, связанных с манипуляцией классами и их элементами. Довольно часто новая функциональность является причиной извлечения новых методов или даже новых классов и/или переименования их, поскольку роль последних может быть расширена, уточнена или специализирована.

Как мне кажется, отдельного внимания, помимо прочих, должны быть удостоены и те части кода, которые давно не редактировались (не были затронуты в процессе исправления ошибок или расширения функциональности), поскольку вряд ли они настолько невосприимчивы к вносимым вами изменениям, хотя и сохраняют корректное поведение. Но это уже ответ скорее не на вопрос “Когда уместно…”, а на вопрос “Где искать…”</Значение>
						<Тип>text</Тип>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_PREVIEW_PICTURE</Ид>
						<Значение>articles_files/iblock/e73/e73c437642eb6f5d0bf02de5b5dd679e.jpg</Значение>
					</ЗначенияСвойства>
				</ЗначенияСвойств>
			</Товар>
			<Товар>
				<Ид>38</Ид>
				<Наименование>Аспектно-ориентированное программирование</Наименование>
				<БитриксТеги></БитриксТеги>
				<Группы>
				</Группы>
				<Картинка>articles_files/iblock/3b4/3b45d073bb4a2294492fd89cec83542a.jpg</Картинка>
				<ЗначенияСвойств>
					<ЗначенияСвойства>
						<Ид>CML2_ACTIVE</Ид>
						<Значение>true</Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_CODE</Ид>
						<Значение>aspektno-orientirovannoe-programmirovanie</Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_SORT</Ид>
						<Значение>500</Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_ACTIVE_FROM</Ид>
						<Значение>2014-03-01 00:00:00</Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_ACTIVE_TO</Ид>
						<Значение></Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_PREVIEW_TEXT</Ид>
						<Значение>Аспектно-ориентированное программирование (АОП) – относительно новая парадигма программирования, появившаяся в начале этого тысячелетия.</Значение>
						<Тип>text</Тип>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_DETAIL_TEXT</Ид>
						<Значение>Аспектно-ориентированное программирование (АОП) – относительно новая парадигма программирования, появившаяся в начале этого тысячелетия. Пройдя по ссылке и прочитав краткий обзор на эту тему, можно долго думать и гадать, а что же такое АОП, и какие цели преследовали те самые сотрудники Xerox, которые ее разрабатывали. 

Обратите внимание, как заметно отличается объем статьи в Википедии, кратко повествующей об АОП от объема статьи про объектно-ориентированное программирование (ООП), концепции которого известны практически всем разработчикам программного обеспечения? Ну да, АОП, судя по тексту, призвано упростить процесс разделения целевой и второстепенной функциональности, которую здесь называют сквозной. Но ведь одной из главных целей создания всех парадигм программирование, и ООП в том числе, является абстрагирование программиста от специфики общения с вычислительной техникой и концентрация его аналитических усилий на целевой функциональности создаваемой им программы. Т.е. на первый взгляд ничего нового. 

С ООП ведь все всем понятно: есть реальный мир, есть объекты реального мира, есть их функциональные и информационные аспекты. С какой стати в общении с вычислительной машиной мы должны обходиться банальными последовательностями операторов, хоть и сгруппированных в процедуры и функции и размещенных в отдельных модулях? Вот и решили ввести в языки программирования понятие объект с его свойствами, методами, инкапсуляцией и т.д. 

А там мысль уже было не остановить, и появились наследование, полиморфизм, шаблоны и т.п. Т.е. все логично. А теперь обратимся к АОП. Здесь отнюдь не все так очевидно, но это и понятно, потому как все гениальное уже придумали, и осталось лишь выдумывать модификации того, что имеем, и выдавать их за нечто уникальное и оригинальное. На самом деле я не хочу сказать, что АОП не заслуживает внимания, напротив, в основе этой концепции лежат вполне себе разумные идеи. 

Я просто хотел заметить, что все новые идеи на фоне того же ООП уже не выглядят чем-то революционным, и по этой причине их могут незаслуженно обделить вниманием. Примером этому служит весьма скромный объем заметки в Википедии. А ведь есть еще и субъектно-ориентированное программирование… Возможно даже такое, что кто-нибудь, видя аббревиатуру АОП, думает, что это опечатка.</Значение>
						<Тип>text</Тип>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_PREVIEW_PICTURE</Ид>
						<Значение>articles_files/iblock/add/add94a132c31574a472a2105dc742141.jpg</Значение>
					</ЗначенияСвойства>
				</ЗначенияСвойств>
			</Товар>
			<Товар>
				<Ид>39</Ид>
				<Наименование>Информационное моделирование</Наименование>
				<БитриксТеги></БитриксТеги>
				<Группы>
				</Группы>
				<Картинка>articles_files/iblock/efe/efeb848c1c62e3f286e19e249c143af1.jpg</Картинка>
				<ЗначенияСвойств>
					<ЗначенияСвойства>
						<Ид>CML2_ACTIVE</Ид>
						<Значение>true</Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_CODE</Ид>
						<Значение>informatsionnoe-modelirovanie</Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_SORT</Ид>
						<Значение>500</Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_ACTIVE_FROM</Ид>
						<Значение>2014-03-01 00:00:00</Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_ACTIVE_TO</Ид>
						<Значение></Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_PREVIEW_TEXT</Ид>
						<Значение>Информационное моделирование для меня означает процесс описания предметной области или построения модели предметной области в том виде или формате, который, с одной стороны, легко воспринимается человеком, и, с другой стороны, легко может быть преобразован в набор элементов информационного хранилища, программных компонентов и других составляющих прикладного программного обеспечения.</Значение>
						<Тип>text</Тип>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_DETAIL_TEXT</Ид>
						<Значение>Информационное моделирование для меня означает процесс описания предметной области или построения модели предметной области в том виде или формате, который, с одной стороны, легко воспринимается человеком, и, с другой стороны, легко может быть преобразован в набор элементов информационного хранилища, программных компонентов и других составляющих прикладного программного обеспечения. Чаще всего термин информационное моделирование можно видеть в контексте описания процесса построения ER диаграмм или UML диаграмм. Существует мнение, что именно эти нотации наиболее удобны для описания модели целевой предметной области перед тем, как воплотить задуманное в виде информационной системы. Как минимум, на счет ER диаграмм у меня есть ряд возражений. Время идет, и многие методики и подходы требуют усовершенствования или замены.

ER диаграммы предназначены в основном для того, чтобы описать структуру реляционной базы данных, которая играет роль информационного хранилища для большей части программных продуктов. Это обстоятельство серьезно ограничивает возможности аналитика, поскольку он вынужден переносить ограничения, присущие реляционной базе данных на свою модель. Иными словами, абстрагироваться от особенностей организации хранения данных в полной мере не удается. Абстракция без лишних ограничений – это залог создания наиболее гибких и адекватных информационных моделей. Немного поясню, что я имею в виду. ER диаграмма – это набор “плоских” сущностей и связей между ними. Под термином “плоский” я понимаю представление моделируемого объекта в виде его названия и характерного для него набора свойств, что однозначно сопоставляется с таблицей реляционной базы данных и ее набором полей. 

Нельзя к объектам относиться так примитивно, даже если разрабатываемый программный продукт должен решать достаточно простые задачи. Рассмотрим простейший пример – программный продукт, который должен обеспечивать информационную поддержку персоналу компании, торгующей недвижимостью, в частности, квартирами. Представление квартиры в виде одной сущности весьма проблематично, поскольку, помимо таких параметров, как возраст объекта, общая и жилая площадь, клиентов интересуют параметры каждой отдельной комнаты. 

Получается, что комнату необходимо выделять в отдельную сущность. А если речь идет о загородной недвижимости или многоэтажных квартирах, то этаж также становится отдельной промежуточной сущностью в модели. С одной стороны вроде бы ничего “криминального”, но в итоге мы получаем, что наша модель состоит как из независимых объектов (дом, квартира), так и из объектов, которые сами по себе существовать не могут (этаж, комната). ER диаграмма не позволяет выходить за пределы измерений “плоского мира” реляционной базы данных. Помимо самих структур данных аналитик также обязан определить правила обеспечения целостности данных: например, при удалении записи о квартире из базы данных должна также исчезнуть информация обо всех ее комнатах – что логично с точки зрения здравого смысла на языке ER диаграмм требует дополнительного описания. Про “искусственные” сущности, которые используются для моделирования связей типа “многие ко многим” вообще отдельный разговор. Иными словами, моделировать предметную область средствами ER диаграмм – малоэффективное занятие.</Значение>
						<Тип>text</Тип>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_PREVIEW_PICTURE</Ид>
						<Значение>articles_files/iblock/71d/71df1e5bd4f63922928632003933224d.jpg</Значение>
					</ЗначенияСвойства>
				</ЗначенияСвойств>
			</Товар>
			<Товар>
				<Ид>40</Ид>
				<Наименование>Структуры данных и оценка сложности алгоритмов</Наименование>
				<БитриксТеги></БитриксТеги>
				<Группы>
				</Группы>
				<Картинка>articles_files/iblock/02e/02ea1dd13a171ad3f725fb7758f1be1a.png</Картинка>
				<ЗначенияСвойств>
					<ЗначенияСвойства>
						<Ид>CML2_ACTIVE</Ид>
						<Значение>true</Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_CODE</Ид>
						<Значение>struktury-dannykh-i-otsenka-slozhnosti-algoritmov</Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_SORT</Ид>
						<Значение>500</Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_ACTIVE_FROM</Ид>
						<Значение>2014-03-01 00:00:00</Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_ACTIVE_TO</Ид>
						<Значение></Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_PREVIEW_TEXT</Ид>
						<Значение>Тема этой статьи снова касается теории программирования, поэтому придется прибегнуть к различным классификациям и оперировать математическими терминами.</Значение>
						<Тип>text</Тип>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_DETAIL_TEXT</Ид>
						<Значение>Тема этой статьи снова касается теории программирования, поэтому придется прибегнуть к различным классификациям и оперировать математическими терминами. Структуры данных – это практически первое, о чем рассказывают в ходе учебных курсов по программированию. Оценка сложности алгоритмов – второе. Может показаться, что эти два вопроса мало связаны, но это не так, и по ходу повествования станет ясно почему. Я не буду углубляться в детали, поскольку практика показывает, что в процессе приобретения опыта в прикладном программировании в голове остается только самое важное. По-моему, так происходит в любой сфере деятельности. Я постараюсь изложить то, что осталось по этим вопросам в голове у меня.</Значение>
						<Тип>text</Тип>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_PREVIEW_PICTURE</Ид>
						<Значение>articles_files/iblock/71b/71bf5ef05cfa96cc7bec98d428357707.png</Значение>
					</ЗначенияСвойства>
				</ЗначенияСвойств>
			</Товар>
			<Товар>
				<Ид>64</Ид>
				<Наименование>Аспектно-ориентированное программирование 2</Наименование>
				<БитриксТеги></БитриксТеги>
				<Группы>
				</Группы>
				<Картинка>articles_files/iblock/2e4/2e42e495d2b93a681f4e180c44e28b94.jpg</Картинка>
				<ЗначенияСвойств>
					<ЗначенияСвойства>
						<Ид>CML2_ACTIVE</Ид>
						<Значение>true</Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_CODE</Ид>
						<Значение>aspektno-orientirovannoe-programmirovanie-2</Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_SORT</Ид>
						<Значение>500</Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_ACTIVE_FROM</Ид>
						<Значение>2014-03-01 00:00:00</Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_ACTIVE_TO</Ид>
						<Значение></Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_PREVIEW_TEXT</Ид>
						<Значение>Аспектно-ориентированное программирование (АОП) – относительно новая парадигма программирования, появившаяся в начале этого тысячелетия.</Значение>
						<Тип>text</Тип>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_DETAIL_TEXT</Ид>
						<Значение>Аспектно-ориентированное программирование (АОП) – относительно новая парадигма программирования, появившаяся в начале этого тысячелетия. Пройдя по ссылке и прочитав краткий обзор на эту тему, можно долго думать и гадать, а что же такое АОП, и какие цели преследовали те самые сотрудники Xerox, которые ее разрабатывали. 

Обратите внимание, как заметно отличается объем статьи в Википедии, кратко повествующей об АОП от объема статьи про объектно-ориентированное программирование (ООП), концепции которого известны практически всем разработчикам программного обеспечения? Ну да, АОП, судя по тексту, призвано упростить процесс разделения целевой и второстепенной функциональности, которую здесь называют сквозной. Но ведь одной из главных целей создания всех парадигм программирование, и ООП в том числе, является абстрагирование программиста от специфики общения с вычислительной техникой и концентрация его аналитических усилий на целевой функциональности создаваемой им программы. Т.е. на первый взгляд ничего нового. 

С ООП ведь все всем понятно: есть реальный мир, есть объекты реального мира, есть их функциональные и информационные аспекты. С какой стати в общении с вычислительной машиной мы должны обходиться банальными последовательностями операторов, хоть и сгруппированных в процедуры и функции и размещенных в отдельных модулях? Вот и решили ввести в языки программирования понятие объект с его свойствами, методами, инкапсуляцией и т.д. 

А там мысль уже было не остановить, и появились наследование, полиморфизм, шаблоны и т.п. Т.е. все логично. А теперь обратимся к АОП. Здесь отнюдь не все так очевидно, но это и понятно, потому как все гениальное уже придумали, и осталось лишь выдумывать модификации того, что имеем, и выдавать их за нечто уникальное и оригинальное. На самом деле я не хочу сказать, что АОП не заслуживает внимания, напротив, в основе этой концепции лежат вполне себе разумные идеи. 

Я просто хотел заметить, что все новые идеи на фоне того же ООП уже не выглядят чем-то революционным, и по этой причине их могут незаслуженно обделить вниманием. Примером этому служит весьма скромный объем заметки в Википедии. А ведь есть еще и субъектно-ориентированное программирование… Возможно даже такое, что кто-нибудь, видя аббревиатуру АОП, думает, что это опечатка.</Значение>
						<Тип>text</Тип>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_PREVIEW_PICTURE</Ид>
						<Значение>articles_files/iblock/2c9/2c9f123916b4d2218cc78ca0b5fa3365.jpg</Значение>
					</ЗначенияСвойства>
				</ЗначенияСвойств>
			</Товар>
			<Товар>
				<Ид>65</Ид>
				<Наименование>Информационное моделирование 2</Наименование>
				<БитриксТеги></БитриксТеги>
				<Группы>
				</Группы>
				<Картинка>articles_files/iblock/236/236937b41a26bfcb8a07da06586cc111.jpg</Картинка>
				<ЗначенияСвойств>
					<ЗначенияСвойства>
						<Ид>CML2_ACTIVE</Ид>
						<Значение>true</Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_CODE</Ид>
						<Значение>informatsionnoe-modelirovanie-2</Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_SORT</Ид>
						<Значение>500</Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_ACTIVE_FROM</Ид>
						<Значение>2014-03-01 00:00:00</Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_ACTIVE_TO</Ид>
						<Значение></Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_PREVIEW_TEXT</Ид>
						<Значение>Информационное моделирование для меня означает процесс описания предметной области или построения модели предметной области в том виде или формате, который, с одной стороны, легко воспринимается человеком, и, с другой стороны, легко может быть преобразован в набор элементов информационного хранилища, программных компонентов и других составляющих прикладного программного обеспечения.</Значение>
						<Тип>text</Тип>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_DETAIL_TEXT</Ид>
						<Значение>Информационное моделирование для меня означает процесс описания предметной области или построения модели предметной области в том виде или формате, который, с одной стороны, легко воспринимается человеком, и, с другой стороны, легко может быть преобразован в набор элементов информационного хранилища, программных компонентов и других составляющих прикладного программного обеспечения. Чаще всего термин информационное моделирование можно видеть в контексте описания процесса построения ER диаграмм или UML диаграмм. Существует мнение, что именно эти нотации наиболее удобны для описания модели целевой предметной области перед тем, как воплотить задуманное в виде информационной системы. Как минимум, на счет ER диаграмм у меня есть ряд возражений. Время идет, и многие методики и подходы требуют усовершенствования или замены.

ER диаграммы предназначены в основном для того, чтобы описать структуру реляционной базы данных, которая играет роль информационного хранилища для большей части программных продуктов. Это обстоятельство серьезно ограничивает возможности аналитика, поскольку он вынужден переносить ограничения, присущие реляционной базе данных на свою модель. Иными словами, абстрагироваться от особенностей организации хранения данных в полной мере не удается. Абстракция без лишних ограничений – это залог создания наиболее гибких и адекватных информационных моделей. Немного поясню, что я имею в виду. ER диаграмма – это набор “плоских” сущностей и связей между ними. Под термином “плоский” я понимаю представление моделируемого объекта в виде его названия и характерного для него набора свойств, что однозначно сопоставляется с таблицей реляционной базы данных и ее набором полей. 

Нельзя к объектам относиться так примитивно, даже если разрабатываемый программный продукт должен решать достаточно простые задачи. Рассмотрим простейший пример – программный продукт, который должен обеспечивать информационную поддержку персоналу компании, торгующей недвижимостью, в частности, квартирами. Представление квартиры в виде одной сущности весьма проблематично, поскольку, помимо таких параметров, как возраст объекта, общая и жилая площадь, клиентов интересуют параметры каждой отдельной комнаты. 

Получается, что комнату необходимо выделять в отдельную сущность. А если речь идет о загородной недвижимости или многоэтажных квартирах, то этаж также становится отдельной промежуточной сущностью в модели. С одной стороны вроде бы ничего “криминального”, но в итоге мы получаем, что наша модель состоит как из независимых объектов (дом, квартира), так и из объектов, которые сами по себе существовать не могут (этаж, комната). ER диаграмма не позволяет выходить за пределы измерений “плоского мира” реляционной базы данных. Помимо самих структур данных аналитик также обязан определить правила обеспечения целостности данных: например, при удалении записи о квартире из базы данных должна также исчезнуть информация обо всех ее комнатах – что логично с точки зрения здравого смысла на языке ER диаграмм требует дополнительного описания. Про “искусственные” сущности, которые используются для моделирования связей типа “многие ко многим” вообще отдельный разговор. Иными словами, моделировать предметную область средствами ER диаграмм – малоэффективное занятие.</Значение>
						<Тип>text</Тип>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_PREVIEW_PICTURE</Ид>
						<Значение>articles_files/iblock/147/14747d2e56979a92b840b319403b702f.jpg</Значение>
					</ЗначенияСвойства>
				</ЗначенияСвойств>
			</Товар>
			<Товар>
				<Ид>66</Ид>
				<Наименование>Структуры данных и оценка сложности алгоритмов 2</Наименование>
				<БитриксТеги></БитриксТеги>
				<Группы>
				</Группы>
				<Картинка>articles_files/iblock/8e5/8e55e84a0c2955fd30a3e12fbd2527c2.png</Картинка>
				<ЗначенияСвойств>
					<ЗначенияСвойства>
						<Ид>CML2_ACTIVE</Ид>
						<Значение>true</Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_CODE</Ид>
						<Значение>struktury-dannykh-i-otsenka-slozhnosti-algoritmov-2</Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_SORT</Ид>
						<Значение>500</Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_ACTIVE_FROM</Ид>
						<Значение>2014-03-01 00:00:00</Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_ACTIVE_TO</Ид>
						<Значение></Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_PREVIEW_TEXT</Ид>
						<Значение>Тема этой статьи снова касается теории программирования, поэтому придется прибегнуть к различным классификациям и оперировать математическими терминами.</Значение>
						<Тип>text</Тип>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_DETAIL_TEXT</Ид>
						<Значение>Тема этой статьи снова касается теории программирования, поэтому придется прибегнуть к различным классификациям и оперировать математическими терминами. Структуры данных – это практически первое, о чем рассказывают в ходе учебных курсов по программированию. Оценка сложности алгоритмов – второе. Может показаться, что эти два вопроса мало связаны, но это не так, и по ходу повествования станет ясно почему. Я не буду углубляться в детали, поскольку практика показывает, что в процессе приобретения опыта в прикладном программировании в голове остается только самое важное. По-моему, так происходит в любой сфере деятельности. Я постараюсь изложить то, что осталось по этим вопросам в голове у меня.</Значение>
						<Тип>text</Тип>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_PREVIEW_PICTURE</Ид>
						<Значение>articles_files/iblock/3bb/3bb46044715ccd7fe07fbf1b3c4fc830.png</Значение>
					</ЗначенияСвойства>
				</ЗначенияСвойств>
			</Товар>
			<Товар>
				<Ид>67</Ид>
				<Наименование>Определение и применение рефакторинга кода 2</Наименование>
				<БитриксТеги></БитриксТеги>
				<Группы>
				</Группы>
				<Картинка>articles_files/iblock/f23/f232db9529d635790c82b32a6a74a1af.jpg</Картинка>
				<ЗначенияСвойств>
					<ЗначенияСвойства>
						<Ид>CML2_ACTIVE</Ид>
						<Значение>true</Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_CODE</Ид>
						<Значение>opredelenie-i-primenenie-refaktoringa-koda-2</Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_SORT</Ид>
						<Значение>500</Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_ACTIVE_FROM</Ид>
						<Значение>2014-02-01 00:00:00</Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_ACTIVE_TO</Ид>
						<Значение></Значение>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_PREVIEW_TEXT</Ид>
						<Значение>Что такое рефакторинг кода понять несложно – определений в сети достаточно много.</Значение>
						<Тип>text</Тип>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_DETAIL_TEXT</Ид>
						<Значение>Что такое рефакторинг кода понять несложно – определений в сети достаточно много. Наиболее удачное и полное, на мой взгляд, в википедии, и не только потому, что оно исчерпывающее, но и потому, что в нем рефакторинг противопоставляется таким этапам жизненного цикла программных продуктов, как оптимизация и реинжиниринг. Познакомиться с этим вариантом определения легко, набрав в строке интернет поиска слово &quot;Рефакторинг&quot; и открыв (скорее всего первую) ссылку на сайт свободной энциклопедии.

Итак, рефакторинг кода – это процесс внесения изменений в исходный код программы посредством небольших преобразований, смысл которых эквивалентен прежним фрагментам, но результат выглядит более стройным, органичным и логичным.
Когда уместно проводить рефакторинг кода?

В жизни каждой программы, по крайней мере, в жизни тех, что разрабатываются на заказ, наступает этап, когда основные функциональные требования заказчика, по мнению разработчика, выполнены, и программный продукт поступает на тестирование. А может быть даже в опытную эксплуатацию. В ходе тестирования, если у того, кто его проводит, руки растут из нужного места и мозги работают в правильном направлении, на разработчика начинает валиться большое число bug-ов, связанных с исключительными ситуациями, “защитой от дурака”, экстремальными объемами данных, неприемлемым быстродействием и так далее (идеально работающие программы сразу не пишутся). Разработчик старается быстро реагировать на вызовы судьбы и вносит большое количество локальных исправлений, а иногда и “заплат”, вследствие чего код теряет первоначальную стройность и сбалансированность. Вот в моменты между основными волнами наплывов претензий со стороны отдела технического контроля или просто ОТК и следует проводить рефакторинг кода: анализировать код и, используя ряд эффективных приемов, преобразовывать его к более согласованному и “прозрачному виду.” Естественно, что этап рефакторинга нельзя считать однократным.

Также, уместно проводить рефакторинг кода после добавления новой функциональности, поскольку такие действия легко могут привести к необходимости провести ряд преобразований, связанных с манипуляцией классами и их элементами. Довольно часто новая функциональность является причиной извлечения новых методов или даже новых классов и/или переименования их, поскольку роль последних может быть расширена, уточнена или специализирована.

Как мне кажется, отдельного внимания, помимо прочих, должны быть удостоены и те части кода, которые давно не редактировались (не были затронуты в процессе исправления ошибок или расширения функциональности), поскольку вряд ли они настолько невосприимчивы к вносимым вами изменениям, хотя и сохраняют корректное поведение. Но это уже ответ скорее не на вопрос “Когда уместно…”, а на вопрос “Где искать…”</Значение>
						<Тип>text</Тип>
					</ЗначенияСвойства>
					<ЗначенияСвойства>
						<Ид>CML2_PREVIEW_PICTURE</Ид>
						<Значение>articles_files/iblock/206/206041578fc05e5a133929d7c66a00bf.jpg</Значение>
					</ЗначенияСвойства>
				</ЗначенияСвойств>
			</Товар>
		</Товары>
	</Каталог>
</КоммерческаяИнформация>
