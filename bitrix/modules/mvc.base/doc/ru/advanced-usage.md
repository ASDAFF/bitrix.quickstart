# "Продвинутое" использование

## Наследование

Решение позволяет не только наследоваться от базового класса, но и наследовать классы компонентов друг от друга. 
При этом наследование касается не только кода. При подключении компонента производится поиск LANG-файлов базового 
класса - по всему дереву вплоть до базового класса CBitrixComponent. 

Таким образом, не обязательно в наследуемых компонентах заново переопределять языковые файлы. 

## Варианты подключения шаблона

В базовом варианте использования шаблон не нужно подключать напрямую - это делается автоматически, файл шаблона
соответствует названию экшена, в которой мы вошли. К примеру, для `actionTwo()` будет автоматически вызвана функция `$this->includeComponentTemplate('two')`.
 
Однако, в случае необходимости, есть возможность подключить свой шаблон прямо в `actionTwo()`. Для этого просто нужно 
вызвать `$this->includeComponentTemplate()`, передав нужное название шаблона. В дальнейшем базовый класс определит, 
что шаблон уже был подключен, и не будет пытаться сделать это повторно.

В случае, если экшн возвращает кастомный http-код, можно воспользоваться хэлпером `$this->setHttpResponseCode()`

## "Жадные" URL

Данная функция никак не документирована в битриксе, хотя активно используется в компонентах вроде каталога.
"Жадные" URL - это url, часть которого может содержать неограниченное количество слешей. Например: 
 - URL: /filter/some/parameters/here/apply
 - Шаблон URL: /filter/#parameters#/apply

В данном примере #parameters# моет содержать в себе неограниченное количество блоков со слешами, пока в конце url не встретиться "/apply".

Возможно также использовать несколько "жадных" блоков, однако они должны быть отделены разделителем. Например:
 - URL: /filter/some/parameters/here/example_separator/some/other/parameters/apply
 - Шаблон URL: /filter/#parameters_1#/example_separator/#parameters_2#/apply
 - Вариант, который не будет работать: /filter/#parameters_1#/#parameters_2#/apply , т.к. парсер не знает, где кончается один
 "жадный" блок, и начинается второй. 
 
Для того, чтобы воспользоваться этим функционалом, нужно: 
 1. Настроить шаблоны URL, как описано выше
 2. В параметрах подключения компонента (либо в параметрах по-умолчанию в .parameters.php) указать ключ `'GREEDY_PARTS' => "parameters_1, parameters_2"`
в котором через запятую будут перечислены плейсхолдеры из шаблона, которые должны содержать "жадные" урлы.
 3. В action-функции указать "жадные" переменные, как обычные: `function actionGreedy($parameters_1, $parameters_2)`. При этом в данные переменные 
будут переданы не строки, а массив с параметрами - в том порядке, в котором элементы шли в строке. 

## Производительность

Компонент работает в 3,4 раза медленнее, чем обычный component.php, в котором используется только CComponentEngine для красивых урлов. 
Т.е. вместо 0,000633 секунды компонент выполняется 0,002166 секунды.
 
Замер производительности производился при следующих условиях: 
 - Выключен режим REST
 - Включено кеширование
 - Нет подгрузки унаследованных у родительского компонента lang-файлов
 - Нет action-классов
 
 С использованием этих функций работа компонента ещё более замедлится. 
 